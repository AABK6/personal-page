<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Big&nbsp;Bang</title>

  <!-- Tailwind (just once) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js and GSAP Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  
  <!-- Chart.js Library (No dependencies!) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Optional: a favicon to silence the 404 -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet" />
  <!-- EB Garamond for captions and chart -->
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            /* overflow: hidden; */
            background-color: #111;
            color: white;
            font-family: 'Inter', sans-serif;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
            z-index: 100;
            transition: opacity 0.5s ease-out;
        }

        /* Keyframe animation for the spinning loader */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        #scene-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: sticky;
            top: 0;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            max-width: 300px;
            font-size: 14px;
            line-height: 1.5;
        }
        .caption-card{
            position:fixed;left:50%;top:15%;transform:translateX(-50%);
            z-index:150;
            background:rgba(0,0,0,.25);
             -webkit-backdrop-filter:blur(4px);
            backdrop-filter:blur(4px);
            padding:.55rem .9rem;border-radius:.65rem;
            font-family:"EB Garamond",serif;
            font-size:clamp(14px,4vw,18px);      /* smaller & responsive */
            font-weight:400;letter-spacing:.2px;
            line-height:1.35;text-align:center;
            max-width:88vw;white-space:normal;   /* wraps on small screens */
            opacity:.6;                          /* base transparency */
        }

        #caption-earth{top:auto; bottom: 12%;}             /* will fade in later */
        #caption-history-1, #caption-history-2 {
            top: auto;
            bottom: 12%;
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .caption-card {
                font-size: clamp(12px, 3vw, 16px);
            }
            #caption-earth, #caption-history-1, #caption-history-2 {
                bottom: 15%;
            }
        }

        .scroll-arrow{
            position:fixed;left:50%;bottom:8%;transform:translateX(-50%);
            z-index:150;
            font-size:26px;color:#fff;opacity:.35;
            animation:arrowPulse 1.6s ease-in-out infinite alternate;
        }

        @keyframes arrowPulse{
          from{transform:translate(-50%,0);}
          to  {transform:translate(-50%,8px);}   /* gentle bounce */
        }


        #population-chart-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none; /* Initially non-interactive */
            transition: opacity 0.5s ease-in-out;
            z-index: 200; /* Ensure it's on top */
        }

    </style>
</head>
<body>
    <!-- Animation 1: The Spinning Loader -->
    <div id="loader">
        <!-- SVG spinner for loading animation -->
        <svg width="32" height="32" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="animate-spin">
            <path d="M11.5262 2.4796C11.5262 1.29002 12.4905 0.325683 13.6801 0.325684C14.8696 0.325684 15.834 1.29002 15.834 2.4796C15.834 3.66917 14.8696 4.63352 13.6801 4.63352C13.2211 4.63352 12.7956 4.48996 12.4462 4.24529L9.25663 7.35216C9.13483 7.10737 8.94113 6.90284 8.70224 6.7646L11.8825 3.66673C11.6573 3.32637 11.5262 2.9183 11.5262 2.4796ZM7.40672 6.6878L4.30542 3.66677C4.53068 3.3264 4.66184 2.91832 4.66184 2.4796C4.66184 1.29002 3.6975 0.325683 2.50793 0.325683C1.31835 0.325683 0.354011 1.29002 0.35401 2.4796C0.35401 3.66917 1.31835 4.63352 2.50793 4.63352C2.96689 4.63352 3.39232 4.48997 3.74178 4.24532L6.78254 7.20738C6.93287 6.97972 7.14989 6.79781 7.40672 6.6878ZM6.75617 8.66022L3.74182 11.5964C3.39236 11.3518 2.96691 11.2082 2.50793 11.2082C1.31836 11.2082 0.354016 12.1725 0.354016 13.3621C0.354016 14.5517 1.31836 15.516 2.50793 15.516C3.69751 15.516 4.66185 14.5517 4.66185 13.3621C4.66185 12.9234 4.53069 12.5153 4.30545 12.175L7.35952 9.20009C7.10816 9.0815 6.89814 8.89286 6.75617 8.66022ZM8.74484 9.11888L11.8823 12.1752C11.6571 12.5155 11.5259 12.9236 11.5259 13.3623C11.5259 14.5519 12.4903 15.5163 13.6798 15.5163C14.8694 15.5163 15.8337 14.5519 15.8337 13.3623C15.8337 12.1728 14.8694 11.2084 13.6798 11.2084C13.2209 11.2084 12.7954 11.352 12.446 11.5966L9.27842 8.51105C9.16543 8.76117 8.97861 8.97251 8.74484 9.11888Z" fill="white"></path>
          </g>
        </svg>
    </div>

    <div id="caption-intro" class="caption-card opacity-0 pointer-events-none">
      Au début, l’univers tout entier tenait ici.
    </div>

    <div id="caption-earth" class="caption-card opacity-0 pointer-events-none">
      Maintenant, toute l’humanité se tient là.
    </div>
    <div id="caption-history-1" class="caption-card">
        Pendant longtemps, nous n'étions pas très nombreux.
    </div>
    <div id="caption-history-2" class="caption-card">
        Puis soudain, tout changea.
    </div>

    <!-- scroll cue -->
    <div id="scroll-arrow" class="scroll-arrow pointer-events-none">
    &#x25BD;
    </div>

    <!-- Info Panel -->
    <div id="info-panel" class="info-panel opacity-0 transition-opacity duration-500">
        <h2 class="font-bold text-lg mb-2">Interactive Particle System</h2>
        <p>This animation replicates the two visual effects you requested from the U x Machina website.</p>
        <ul class="list-disc list-inside mt-2">
            <li>Move your mouse to interact with the particles.</li>
            <li>Click and drag to rotate the camera.</li>
            <li>Scroll to zoom in and out.</li>
        </ul>
        <p class="mt-2 text-xs text-gray-400">This is a simplified replication for demonstration.</p>
    </div>

    <!-- Animation 2: The Particle System Canvas -->
    <canvas id="scene-container"></canvas>

    <!-- Population Chart Container -->
    <div id="population-chart-container">
        <!-- Header -->
        <div class="absolute top-4 left-0 w-full text-center z-10 pointer-events-none">
            <h1 class="text-3xl sm:text-5xl font-thin text-white tracking-wider" style="font-family: 'EB Garamond', serif;">Humanity</h1>
            <p class="text-sky-300/70 text-sm sm:text-base mt-1 font-light">The Rise of Population</p>
        </div>

        <!-- Main Chart Area -->
        <div class="relative w-full h-full max-w-6xl mx-auto flex flex-col justify-center p-4 sm:p-8">
            <!-- Glassmorphism Panel -->
            <div class="absolute inset-4 sm:inset-8 bg-slate-900/30 backdrop-blur-sm rounded-xl border border-white/10 shadow-2xl -z-10"></div>

            <div class="relative w-full h-[70vh] sm:h-[80vh]">
                <canvas id="popChart"></canvas>
                
                <!-- Overlay Stat -->
                <div class="absolute top-4 left-4 sm:left-8 pointer-events-none">
                    <div class="text-gray-400 text-xs sm:text-sm uppercase tracking-widest">Year <span id="stat-year">0</span></div>
                    <div id="stat-pop" class="text-3xl sm:text-5xl text-white font-medium tabular-nums" style="font-family: 'EB Garamond', serif; text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);">
                        0
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="w-full max-w-2xl mx-auto mt-4 z-10 flex items-center gap-4 bg-slate-900/60 backdrop-blur-md p-3 rounded-full border border-white/10 shadow-xl">
                <button id="btn-play" class="flex items-center justify-center w-10 h-10 sm:w-12 sm:h-12 bg-sky-500 hover:bg-sky-400 text-white rounded-full transition-all shadow-[0_0_15px_rgba(14,165,233,0.5)] hover:scale-105 flex-shrink-0">
                    <svg id="icon-play" width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="icon-pause" class="hidden" width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                    <svg id="icon-replay" class="hidden" width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                </button>
                <input type="range" id="slider-year" class="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-sky-400 hover:accent-sky-300">
            </div>
        </div>
    </div>

    <!-- Spacer for scrolling -->
    <div style="height: 300vh;"></div>

    <script>
        // Libraries are loaded globally from the <head>

        // --- Basic Setup ---
        let scene, camera, renderer, particles, controls;
        let earthMesh, cloudsMesh, atmosphereMesh;
        let mouse = new THREE.Vector2(-100, -100); // Off-screen initially
        const particleCount = 15000; // Number of particles in the system
        const sphereRadius = 3; // radius of the sphere for initial particle positions
        const gridDimensions = 160; // size of the grid area
        const EARTH_RADIUS = 0.5;
        const pointers = new Map();
        const captionIntro  = document.getElementById('caption-intro');
        const captionEarth  = document.getElementById('caption-earth');
        const scrollArrow   = document.getElementById('scroll-arrow');
        const chartContainer = document.getElementById('population-chart-container');

        const spherePositions = []; // Stores initial sphere positions for each particle
        const gridPositions = [];   // Stores grid positions for each particle
        let animationState = 'sphere'; // sphere, exploding, grid, journeying, focused, chart
        let targetParticleIndex; // Index of the special particle for the camera journey
        let targetParticlePosition = new THREE.Vector3(); // Position of the target particle
        let canShowChart = false; // Flag to control chart visibility
        const chartThreshold = 2200; // Reduced from 3000 to make chart appear sooner

        let virtualScrollY = 0; // Smoothed scroll position
        let targetScrollY = 0;  // Target scroll position (raw input)
        let scrollSpeed = 0.07; // Adjust for smoother or faster interpolation

        // --- Event Handlers ---
        function onWindowResize() {
            // Update camera and renderer on window resize
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Normalize mouse position to [-1, 1] for use in shaders
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWheel(event) {
            // During the narrative part, we prevent default to control the scene.
            event.preventDefault();
            targetScrollY += event.deltaY * 0.5;
            // When focused on the Earth, OrbitControls no longer handles scroll for zooming.
        }

        let lastTouchY = 0;
        function onTouchStart(event) {
            // Store initial Y position for touch scrolling
            lastTouchY = event.touches[0].clientY;
        }

        function onTouchMove(event) {
            // Handle vertical touch movement for scrolling
            event.preventDefault();
            const currentY = event.touches[0].clientY;
            const deltaY = lastTouchY - currentY;
            targetScrollY += deltaY;
            lastTouchY = currentY;
        }

        function handleScroll(scrollY) {
            // Handles scroll-based transitions and camera zoom
            const explosionThreshold = 500; // When to trigger sphere-to-grid
            const journeyThreshold = 1500;  // When to trigger camera journey
            const maxZoom = 10;
            const minZoom = 35;

            // Only control zoom if we are not on the final journey
            if (animationState !== 'journeying' && animationState !== 'focused' && animationState !== 'chart') {
                const zoom = minZoom - (scrollY / 60);
                camera.position.z = Math.max(zoom, maxZoom);
            }

            // Trigger transitions based on scroll position
            if (scrollY > explosionThreshold && animationState === 'sphere') {
                transitionToGrid();
            } else if (scrollY > journeyThreshold && animationState === 'grid') {
                startJourneyToParticle();
            } else if (scrollY > chartThreshold && animationState === 'focused' && canShowChart) {
                animationState = 'chart';
                chartContainer.style.opacity = 1;
                chartContainer.style.pointerEvents = 'auto';
                
                // Fade out the Earth caption and the scroll arrow
                gsap.to([captionEarth, scrollArrow], {opacity: 0, duration: 0.6, ease:"power2.in"});
            }

            if (animationState === 'chart') {
                const chartScroll = scrollY - chartThreshold;
                const progress = Math.min(1, Math.max(0, chartScroll / (document.body.scrollHeight - window.innerHeight - chartThreshold)));
                
                // Dispatch a custom event with the progress
                const event = new CustomEvent('update-chart', { detail: { progress } });
                window.dispatchEvent(event);
            }
        }

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111111, 10, 20); // Add fog for depth effect

            // --- Lighting for the globe ---
            const sun = new THREE.DirectionalLight(0xffffff, 2); // brighter key light
            sun.position.set(5, 3, 5);
            scene.add(sun);

            scene.add(new THREE.AmbientLight(0x666666));         // slightly brighter fill

            // Camera
            camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.1, 1000); // Perspective camera : FOV, aspect ratio, near and far planes
            camera.position.z = 40; // Start far away

            // Renderer
            const canvas = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.domElement.style.touchAction = 'none';   // canvas owns all touch gestures

            // Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 3;
            controls.maxDistance = 40;

            /* --- mobile touch mapping ---
            controls.touches.ONE = THREE.TOUCH.NONE;          // disable 1-finger rotate
            controls.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;  // 2-fingers = zoom + orbit
            // optional: keep three-finger pan

            canvas.addEventListener('pointerdown', e => {
                pointers.set(e.pointerId, e.clientY);
            });

            canvas.addEventListener('pointermove', e => {
                if (!pointers.has(e.pointerId)) return;

                // How many pointers are currently active?
                if (pointers.size === 1) {                   // ← our "narrative swipe"
                    const lastY = pointers.get(e.pointerId);
                    const dy    = lastY - e.clientY;
                    pointers.set(e.pointerId, e.clientY);

                    // feed vertical delta into timeline
                    targetScrollY += dy;
                    e.preventDefault();                      // stop page scroll / rubber-band
                }
                // else (2+ pointers) do nothing – OrbitControls no longer handles scroll for zooming.
            }, { passive:false });

            ['pointerup','pointercancel','pointerleave','pointerout']
            .forEach(type => canvas.addEventListener(type, e => {
                pointers.delete(e.pointerId);
            })); */

            // --- Manager & Loaders ---
            const manager = new THREE.LoadingManager();
            manager.onLoad = function() {
                const loaderEl = document.getElementById('loader');
                const infoEl = document.getElementById('info-panel');
                if(loaderEl) {
                    loaderEl.style.opacity = '0';
                    setTimeout(() => {
                        loaderEl.style.display = 'none';
                        if(infoEl) infoEl.classList.remove('opacity-0');
                        gsap.to([captionIntro, scrollArrow], {opacity:0.6, duration:1.2, ease:"power2.out", onComplete: () => {
                            window.addEventListener('wheel', handleFirstScroll, { once: true });
                            window.addEventListener('touchmove', handleFirstScroll, { once: true });
                        }});
                    }, 500);
                }
            };

            // Use manager for textures
            const textureLoader = new THREE.TextureLoader(manager).setCrossOrigin('anonymous');
            
            // Preload Earth textures immediately
            const earthMap   = textureLoader.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_atmos_2048.jpg', t => t.encoding = THREE.sRGBEncoding);
            const bumpMap    = textureLoader.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_normal_2048.jpg');
            const specMap    = textureLoader.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_specular_2048.jpg');
            const cloudsMap  = textureLoader.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_clouds_1024.png');


            // --- Particle Creation ---
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3); // Sphere positions (Start)
            const targetPositions = new Float32Array(particleCount * 3); // Grid positions (End)
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const initialColors = new Float32Array(particleCount * 3);
            const delays = new Float32Array(particleCount); // Animation start delay

            const color = new THREE.Color(); 

            // 1. Generate Sphere Positions
            for (let i = 0; i < particleCount; i++) {
                // Fibonacci sphere algorithm
                const phi = Math.acos(-1 + (2 * i) / particleCount);
                const theta = Math.sqrt(particleCount * Math.PI) * phi;

                const x = sphereRadius * Math.cos(theta) * Math.sin(phi);
                const y = sphereRadius * Math.sin(theta) * Math.sin(phi);
                const z = sphereRadius * Math.cos(phi);

                spherePositions.push(x, y, z); 
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Assign color using HSL
                color.setHSL(i / particleCount, 1.0, 0.5);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;

                initialColors[i*3] = color.r;
                initialColors[i*3+1] = color.g;
                initialColors[i*3+2] = color.b;

                sizes[i] = Math.random() * 0.5 + 0.01; 
            }

            // 2. Generate Grid Positions
            targetParticleIndex = Math.floor(Math.random() * particleCount); 

            for (let i = 0; i < particleCount; i++) {
                 // Random grid position within the cube
                 const x = (Math.random() - 0.5) * gridDimensions;
                 const y = (Math.random() - 0.5) * gridDimensions;
                 const z = (Math.random() - 0.5) * gridDimensions;
                 gridPositions.push(x, y, z);

                 targetPositions[i * 3] = x;
                 targetPositions[i * 3 + 1] = y;
                 targetPositions[i * 3 + 2] = z;

                 // Random delay for the explosion effect (0s to 1.5s)
                 delays[i] = Math.random() * 1.5; 

                 if (i === targetParticleIndex) {
                    targetParticlePosition.set(x, y, z);
                 }
            }

            // --- Create Earth ---
            earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 64, 64),
            new THREE.MeshPhongMaterial({
                map: earthMap,
                bumpMap: bumpMap,
                bumpScale: 0.005,
                specularMap: specMap,
                shininess: 5
            })
            );
            earthMesh.position.copy(targetParticlePosition);
            earthMesh.visible = false;
            scene.add(earthMesh);

            // Clouds
            cloudsMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.503, 64, 64),
            new THREE.MeshPhongMaterial({
                map: cloudsMap,
                transparent: true,
                depthWrite: false
            })
            );
            cloudsMesh.position.copy(targetParticlePosition);
            cloudsMesh.visible = false;
            scene.add(cloudsMesh);

            // Atmosphere
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: { 'c':{value:1.0}, 'p':{value:2.0}, glowColor:{value:new THREE.Color(0x3b8cff)}},
                vertexShader: `varying vec3 vNormal; void main(){vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);} `,
                fragmentShader:`uniform vec3 glowColor; uniform float c; uniform float p; varying vec3 vNormal;
                    void main(){float intensity = pow(c - dot(vNormal, vec3(0.0,0.0,1.0)), p); gl_FragColor = vec4(glowColor * intensity, 1.0);} `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            atmosphereMesh = new THREE.Mesh(new THREE.SphereGeometry(0.53,64,64), glowMaterial);
            atmosphereMesh.position.copy(targetParticlePosition);
            atmosphereMesh.visible = false;
            scene.add(atmosphereMesh);

            // Hide target particle
            sizes[targetParticleIndex] = 0;

            // Assign attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPos', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('initialColor', new THREE.BufferAttribute(initialColors, 3)); 
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aDelay', new THREE.BufferAttribute(delays, 1));

            // Custom Shaders
            const vertexShader = `
                attribute float size;
                attribute vec3 aTargetPos;
                attribute float aDelay;
                
                varying vec3 vColor;
                
                uniform vec3 uMouse;
                uniform float uInteractionRadius;
                uniform float uTransitionProgress;

                varying float vHighlight;

                void main() {
                    vColor = color;

                    // GPU Animation Logic
                    float duration = 1.5; 
                    // Calculate normalized time t for this particle based on delay
                    float t = clamp((uTransitionProgress - aDelay) / duration, 0.0, 1.0);
                    
                    // Smooth easing
                    t = t * t * (3.0 - 2.0 * t); 

                    // Interpolate position
                    vec3 currentPos = mix(position, aTargetPos, t);

                    // Interaction Logic (Mouse)
                    float dist = length(currentPos - uMouse);
                    float falloff = 1.0;
                    vHighlight = 1.0 - smoothstep(uInteractionRadius, uInteractionRadius + falloff, dist);

                    vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            const fragmentShader = `
                varying vec3 vColor;
                varying float vHighlight;

                void main() {
                    if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
                    vec3 highlightColor = vec3(1.0, 1.0, 1.0);
                    vec3 finalColor = mix(vColor, highlightColor, vHighlight);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uMouse: { value: new THREE.Vector3(-100, -100, 0) },
                    uInteractionRadius: { value: 1.5 },
                    uTransitionProgress: { value: 0.0 } // Start at sphere state
                },
                vertexShader,
                fragmentShader,
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            particles.frustumCulled = false;
            scene.add(particles);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('wheel', onWheel, { passive: false });

            // (Loader handled by manager.onLoad)
        }

        function handleFirstScroll() {
            gsap.to([captionIntro, scrollArrow], {opacity: 0, duration: 0.6, ease:"power2.in"});
        }

        // --- Transition Animations ---
        function transitionToGrid() {
            // Transition from sphere to grid layout (GPU Version)
            animationState = 'exploding';

            // 1. Expand interaction radius
            gsap.to(particles.material.uniforms.uInteractionRadius, {
                value: 6.0, 
                duration: 4,
                ease: "power3.inOut"
            });

            // 2. Animate the uniform "uTransitionProgress"
            // The shader logic is: t = clamp((uTransitionProgress - aDelay) / duration, 0, 1)
            // Max delay is 1.5s. Duration is 1.5s.
            // So for the last particle (delay 1.5), t starts increasing at 1.5 and finishes at 3.0.
            // We tween uTransitionProgress from 0.0 to 3.5 to be safe.
            
            gsap.to(particles.material.uniforms.uTransitionProgress, {
                value: 3.5,
                duration: 5.0, // Overall duration of the explosion sequence
                ease: "power2.inOut",
                onComplete: () => {
                    animationState = 'grid';
                }
            });
        }

        function startJourneyToParticle() {
            // Camera flies to a specific particle in the grid
            animationState = 'journeying';
            controls.enabled = false;

            // A fixed viewing position relative to the Earth for a consistent final view
            const cameraEndPosition = targetParticlePosition.clone().add(new THREE.Vector3(0, EARTH_RADIUS * 0.5, EARTH_RADIUS * 4));
            const startPosition     = camera.position.clone();

            // Control point for the bezier curve, creating an arc
            const controlPoint      = new THREE.Vector3()
                .lerpVectors(startPosition, cameraEndPosition, 0.5)
                .add(new THREE.Vector3(0, startPosition.distanceTo(cameraEndPosition) * 0.2, 0));

            // Create a three.js curve object for the camera's path.
            const curve = new THREE.QuadraticBezierCurve3(
                startPosition,
                controlPoint,
                cameraEndPosition
            );

            const journeyLookAtTarget = new THREE.Vector3().copy(controls.target);

            const tl = gsap.timeline({
                onStart: () => {
                    // Make Earth visible and fade it in
                    earthMesh.visible = true;
                    cloudsMesh.visible = true;
                    atmosphereMesh.visible = true;
                    gsap.fromTo([earthMesh.material, cloudsMesh.material, atmosphereMesh.material],
                        { opacity: 0 },
                        { opacity: 1, duration: 1.5, ease: "power2.out" }
                    );
                },
                onComplete: () => {
                    // Finalize the scene
                    gsap.fromTo(captionEarth, { opacity: 0 }, { opacity: .6, duration: 1.2, ease: "power2.out", onComplete: () => {
                        canShowChart = true;
                        animationState = 'focused';
                        controls.enabled = true;
                        controls.minDistance = EARTH_RADIUS * 1.1;
                        controls.maxDistance = EARTH_RADIUS * 5;
                        // Update the official OrbitControls target and sync
                        controls.target.copy(targetParticlePosition);
                        controls.update();
                        
                        // AUTO-GUIDE: If user hasn't scrolled enough, gently push them to the chart
                        if (targetScrollY < chartThreshold) {
                             // Animate the scroll variable itself
                             const scrollProxy = { val: targetScrollY };
                             gsap.to(scrollProxy, {
                                 val: chartThreshold + 100, // Add a bit more buffer
                                 duration: 1.5,             // Faster transition
                                 ease: "power2.inOut",
                                 onUpdate: () => {
                                     targetScrollY = scrollProxy.val;
                                 }
                             });
                        }
                    }});
                }
            });

            // --- PHASE 1: PIVOT ---
            // Animate the look-at target to pivot the camera towards the Earth.
            tl.to(journeyLookAtTarget, {
                x: targetParticlePosition.x,
                y: targetParticlePosition.y,
                z: targetParticlePosition.z,
                duration: 5, // Duration for the pivot
                ease: "power2.inOut",
                onUpdate: () => {
                    camera.lookAt(journeyLookAtTarget);
                }
            });

            // --- PHASE 2: JOURNEY ---
            // Animate a proxy value from 0 to 1 to control the camera's position along the curve.
            const journeyProxy = { t: 0 };
            tl.to(journeyProxy, {
                t: 1,
                duration: 7, // Duration for the journey itself
                ease: "power3.inOut",
                onUpdate: () => {
                    // Use the curve's .getPoint() method to update the camera's position.
                    curve.getPoint(journeyProxy.t, camera.position);
                    // Ensure the camera keeps looking at the final destination during the flight.
                    camera.lookAt(targetParticlePosition);
                }
            });
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (earthMesh) {
                earthMesh.rotation.y  += 0.0005;   // slow spin
                cloudsMesh.rotation.y += 0.0006;   // clouds a bit faster
            }

            // Smoothly interpolate the virtual scroll position
            virtualScrollY += (targetScrollY - virtualScrollY) * scrollSpeed;
            handleScroll(virtualScrollY);

            if (animationState !== 'journeying') {
                controls.update();
            }

            // Project mouse onto a plane at z=0 in world space
            const mouseWorld = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
            const direction = mouseWorld.sub(camera.position).normalize();
            const distanceToPlane = -camera.position.z / direction.z;
            const mouseOnPlane = camera.position.clone().add(direction.multiplyScalar(distanceToPlane));

            // Update the shader uniform for mouse position
            particles.material.uniforms.uMouse.value.copy(mouseOnPlane);

            renderer.render(scene, camera);
        }

        // --- Start ---
        init(); // Initialize scene and objects
        animate(); // Start animation loop
    </script>
    <script>
        // --- Chart.js Implementation ---
        (function() {
            const CSV_DATA = `Entity,Code,Year,Population (historical estimates and future projections)
World,OWID_WRL,-10000,4501152
World,OWID_WRL,-9000,5687125
World,OWID_WRL,-8000,7314623
World,OWID_WRL,-7000,9651703
World,OWID_WRL,-6000,13278309
World,OWID_WRL,-5000,19155698
World,OWID_WRL,-4000,28859174
World,OWID_WRL,-3000,44577880
World,OWID_WRL,-2000,72685064
World,OWID_WRL,-1000,110530464
World,OWID_WRL,0,232268832
World,OWID_WRL,100,237052192
World,OWID_WRL,200,240762160
World,OWID_WRL,300,227702848
World,OWID_WRL,400,241697008
World,OWID_WRL,500,253395808
World,OWID_WRL,600,271638944
World,OWID_WRL,700,278346080
World,OWID_WRL,800,285870176
World,OWID_WRL,900,311142688
World,OWID_WRL,1000,323462624
World,OWID_WRL,1500,503051104
World,OWID_WRL,1600,516147616
World,OWID_WRL,1700,595456896
World,OWID_WRL,1800,954892352
World,OWID_WRL,1820,1065623616
World,OWID_WRL,1830,1148205440
World,OWID_WRL,1840,1209754496
World,OWID_WRL,1850,1287033856
World,OWID_WRL,1950,2493092801
World,OWID_WRL,1951,2536926981
World,OWID_WRL,1952,2584086282
World,OWID_WRL,1953,2634106196
World,OWID_WRL,1954,2685894824
World,OWID_WRL,1955,2740213742
World,OWID_WRL,1960,3015470858
World,OWID_WRL,1965,3334533671
World,OWID_WRL,1970,3694683753
World,OWID_WRL,1975,4070735208
World,OWID_WRL,1980,4447606162
World,OWID_WRL,1985,4868943409
World,OWID_WRL,1990,5327803039
World,OWID_WRL,1995,5758878939
World,OWID_WRL,2000,6171702952
World,OWID_WRL,2005,6586970109
World,OWID_WRL,2010,7021732097
World,OWID_WRL,2015,7470491849
World,OWID_WRL,2020,7887001253
World,OWID_WRL,2021,7954448327
World,OWID_WRL,2022,8021407128
World,OWID_WRL,2023,8091734853
World,OWID_WRL,2024,8161972496
World,OWID_WRL,2025,8231613055
World,OWID_WRL,2030,8569124874
World,OWID_WRL,2040,9177190161
World,OWID_WRL,2050,9664378554
World,OWID_WRL,2060,9989232258
World,OWID_WRL,2070,10189241908
World,OWID_WRL,2080,10283077976
World,OWID_WRL,2090,10271565034
World,OWID_WRL,2100,10180160680`;

            // Parse Data
            const rawData = CSV_DATA.trim().split('\n').slice(1).map(line => {
                const parts = line.split(',');
                return { x: parseInt(parts[2]), y: parseInt(parts[3]) };
            }).filter(d => d.x <= 2025).sort((a, b) => a.x - b.x);

            const minYear = rawData[0].x;
            const maxYear = 2025;
            let currentYear = minYear;
            let isPlaying = false;
            let animationFrameId;
            let chart;

            // Initialize Chart
            const ctx = document.getElementById('popChart').getContext('2d');
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 600);
            gradient.addColorStop(0, 'rgba(14, 165, 233, 0.6)'); // Sky-500
            gradient.addColorStop(1, 'rgba(14, 165, 233, 0)');

            // Custom Plugin for Industrial Revolution Line
            const industrialRevolutionLine = {
                id: 'industrialRevolutionLine',
                afterDraw: (chart) => {
                    const year = 1760;
                    // Check if we have reached this year in the animation
                    const meta = chart.getDatasetMeta(0);
                    if (!meta || !chart.data.datasets[0].data.length) return;
                    
                    const lastDataPoint = chart.data.datasets[0].data[chart.data.datasets[0].data.length - 1];
                    if (!lastDataPoint || lastDataPoint.x < year) return;

                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    const x = xAxis.getPixelForValue(year);
                    
                    // Calculate opacity based on how far past the year we are (fade in effect)
                    const progress = Math.min(1, (lastDataPoint.x - year) / 50);
                    if (progress <= 0) return;

                    ctx.save();
                    ctx.globalAlpha = progress;
                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#38bdf8'; // Sky-400
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#38bdf8';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'top';
                    ctx.font = "14px 'EB Garamond'";
                    ctx.fillText("Industrial Revolution", x - 5, yAxis.top + 10);
                    ctx.restore();
                }
            };

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Population',
                        data: [rawData[0]], // Start with just the first point
                        borderColor: '#38bdf8', 
                        backgroundColor: gradient,
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true,
                        tension: 0.4
                    }]
                },
                plugins: [industrialRevolutionLine],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, 
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: minYear,
                            max: maxYear,
                            grid: { display: false },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(val) { return Math.abs(val) + (val < 0 ? ' BC' : ''); }
                            }
                        },
                        y: {
                            type: 'linear',
                            min: 0,
                            max: 10000000000,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(val) { return (val/1e9).toFixed(0) + 'B'; }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(15, 23, 42, 0.9)',
                            titleColor: '#94a3b8',
                            bodyColor: '#38bdf8',
                            callbacks: {
                                title: (items) => 'Year ' + Math.abs(items[0].parsed.x) + (items[0].parsed.x < 0 ? ' BC' : ''),
                                label: (item) => (item.parsed.y / 1e9).toFixed(2) + ' Billion'
                            }
                        }
                    }
                }
            });

            // DOM Elements
            const slider = document.getElementById('slider-year');
            const btnPlay = document.getElementById('btn-play');
            const iconPlay = document.getElementById('icon-play');
            const iconPause = document.getElementById('icon-pause');
            const iconReplay = document.getElementById('icon-replay');
            const statYear = document.getElementById('stat-year');
            const statPop = document.getElementById('stat-pop');

            slider.min = minYear;
            slider.max = maxYear;
            slider.value = minYear;

            function formatPop(n) {
                if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
                if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
                return n.toLocaleString();
            }

            // Interpolation Function
            function getDataAtYear(year) {
                const nextIndex = rawData.findIndex(d => d.x > year);
                if (nextIndex === -1) return rawData[rawData.length - 1];
                if (nextIndex === 0) return rawData[0];

                const prev = rawData[nextIndex - 1];
                const next = rawData[nextIndex];
                const ratio = (year - prev.x) / (next.x - prev.x);
                return {
                    x: year,
                    y: prev.y + (next.y - prev.y) * ratio
                };
            }

            function updateDisplay(year) {
                // Update Slider & Text
                slider.value = year;
                statYear.innerText = Math.abs(year) + (year < 0 ? ' BC' : '');
                const currentData = getDataAtYear(year);
                statPop.innerText = formatPop(currentData.y);

                // Update Chart Viewport
                // Technique: We filter the dataset itself to simulate "growing"
                const filteredData = rawData.filter(d => d.x <= year);
                // Add current interpolated point
                filteredData.push(currentData);
                
                chart.data.datasets[0].data = filteredData;
                chart.update('none'); // 'none' mode for performance
            }

            function play() {
                isPlaying = true;
                updateIcon();
                loop();
            }

            function pause() {
                isPlaying = false;
                updateIcon();
                cancelAnimationFrame(animationFrameId);
            }

            function updateIcon() {
                iconPlay.classList.add('hidden');
                iconPause.classList.add('hidden');
                iconReplay.classList.add('hidden');
                
                if (currentYear >= maxYear) {
                    iconReplay.classList.remove('hidden');
                } else if (isPlaying) {
                    iconPause.classList.remove('hidden');
                } else {
                    iconPlay.classList.remove('hidden');
                }
            }

            function loop() {
                if (!isPlaying) return; 
                
                // Variable speed logic
                let step = 0.5; // Base step for slowest part (modern era)
                if (currentYear < 1700) step = 25;      // Ancient history: Very fast (50 -> 25)
                else if (currentYear < 1800) step = 2.5;  // Pre-Industrial: Medium (5 -> 2.5)
                else if (currentYear < 1950) step = 1;  // Industrial: Slower (2 -> 1)
                else step = 0.5;                        // Modern: Real-time detail (1 -> 0.5)

                currentYear += step;

                if (currentYear >= maxYear) {
                    currentYear = maxYear;
                    pause();
                } else {
                    animationFrameId = requestAnimationFrame(loop);
                }
                updateDisplay(currentYear);
            }

            // Listeners
            btnPlay.addEventListener('click', () => {
                if (currentYear >= maxYear) {
                    currentYear = minYear;
                    play();
                } else if (isPlaying) {
                    pause();
                } else {
                    play();
                }
            });

            slider.addEventListener('input', (e) => {
                pause();
                currentYear = parseInt(e.target.value);
                updateDisplay(currentYear);
            });
            
            // SCROLL SYNCHRONIZATION
            // This links the scroll position (passed from the main script) to the chart year.
            window.addEventListener('update-chart', (e) => {
               if (isPlaying) return; // Don't override if user is manually playing
               
               const progress = e.detail.progress; // 0 to 1
               // Map progress to year range
               let targetYear = minYear + (maxYear - minYear) * progress;
               targetYear = Math.floor(targetYear);
               
               // Clamp
               if (targetYear < minYear) targetYear = minYear;
               if (targetYear > maxYear) targetYear = maxYear;
               
               currentYear = targetYear;
               updateDisplay(currentYear);
            });

            // Initial render
            updateDisplay(minYear);
            console.log("Chart.js initialized successfully.");

        })();
    </script>
</body>
</html>