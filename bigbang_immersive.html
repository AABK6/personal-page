<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Big Bang - Immersive (Option A)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=EB+Garamond:wght@400;500&display=swap" rel="stylesheet" />
  
  <style>
    body, html { margin: 0; padding: 0; background: #111; color: white; overflow: hidden; }
    #root { width: 100vw; height: 100vh; }
    
    /* UI Overlays matching original exactly */
    .caption-card {
        font-family: "EB Garamond", serif;
        background: rgba(0,0,0,0.25);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        padding: .55rem .9rem;
        border-radius: .65rem;
        text-align: center;
        font-size: clamp(14px, 4vw, 18px);
        letter-spacing: .2px;
        line-height: 1.35;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        pointer-events: none;
        color: white;
        opacity: 0.6; /* Base opacity from original CSS */
    }

    .scroll-arrow {
        font-size: 26px;
        color: #fff;
        opacity: .35;
        animation: arrowPulse 1.6s ease-in-out infinite alternate;
    }

    @keyframes arrowPulse {
        from { transform: translateY(0); }
        to { transform: translateY(8px); }
    }

    /* Loader Styles */
    #loader {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; justify-content: center; align-items: center;
        background-color: #111; z-index: 9999; transition: opacity 0.5s ease-out;
    }
    .animate-spin { animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    canvas#popChart { width: 100% !important; height: 100% !important; }
  </style>

  <!-- Robust Import Map: All dependencies from esm.sh to ensure shared Three.js instance -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "three": "https://esm.sh/three@0.160.0",
      "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
      "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
      "xstate": "https://esm.sh/xstate@5.7.0",
      "@xstate/react": "https://esm.sh/@xstate/react@4.1.0?external=react,xstate",
      "gsap": "https://esm.sh/gsap@3.12.5",
      "chart.js/auto": "https://esm.sh/chart.js@4.4.1/auto",
      "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <!-- HTML Loader (Outside React to show immediately) -->
  <div id="loader">
      <svg width="32" height="32" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="animate-spin">
          <path d="M11.5262 2.4796C11.5262 1.29002 12.4905 0.325683 13.6801 0.325684C14.8696 0.325684 15.834 1.29002 15.834 2.4796C15.834 3.66917 14.8696 4.63352 13.6801 4.63352C13.2211 4.63352 12.7956 4.48996 12.4462 4.24529L9.25663 7.35216C9.13483 7.10737 8.94113 6.90284 8.70224 6.7646L11.8825 3.66673C11.6573 3.32637 11.5262 2.9183 11.5262 2.4796ZM7.40672 6.6878L4.30542 3.66677C4.53068 3.3264 4.66184 2.91832 4.66184 2.4796C4.66184 1.29002 3.6975 0.325683 2.50793 0.325683C1.31835 0.325683 0.354011 1.29002 0.35401 2.4796C0.35401 3.66917 1.31835 4.63352 2.50793 4.63352C2.96689 4.63352 3.39232 4.48997 3.74178 4.24532L6.78254 7.20738C6.93287 6.97972 7.14989 6.79781 7.40672 6.6878ZM6.75617 8.66022L3.74182 11.5964C3.39236 11.3518 2.96691 11.2082 2.50793 11.2082C1.31836 11.2082 0.354016 12.1725 0.354016 13.3621C0.354016 14.5517 1.31836 15.516 2.50793 15.516C3.69751 15.516 4.66185 14.5517 4.66185 13.3621C4.66185 12.9234 4.53069 12.5153 4.30545 12.175L7.35952 9.20009C7.10816 9.0815 6.89814 8.89286 6.75617 8.66022ZM8.74484 9.11888L11.8823 12.1752C11.6571 12.5155 11.5259 12.9236 11.5259 13.3623C11.5259 14.5519 12.4903 15.5163 13.6798 15.5163C14.8694 15.5163 15.8337 14.5519 15.8337 13.3623C15.8337 12.1728 14.8694 11.2084 13.6798 11.2084C13.2209 11.2084 12.7954 11.352 12.446 11.5966L9.27842 8.51105C9.16543 8.76117 8.97861 8.97251 8.74484 9.11888Z" fill="white"></path>
      </svg>
  </div>

  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useMemo, useLayoutEffect } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';
    import { ScrollControls, Scroll, useScroll, Html } from '@react-three/drei';
    import { createMachine, assign } from 'xstate';
    import { useMachine } from '@xstate/react';
    import gsap from 'gsap';
    import Chart from 'chart.js/auto';
    
    // CORRECTLY IMPORT POST-PROCESSING FROM SAME SOURCE (esm.sh)
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Register with R3F
    extend({ EffectComposer, RenderPass, UnrealBloomPass, ShaderPass });

    const CSV_DATA = `Entity,Code,Year,Population (historical estimates and future projections)
World,OWID_WRL,-10000,4501152
World,OWID_WRL,-9000,5687125
World,OWID_WRL,-8000,7314623
World,OWID_WRL,-7000,9651703
World,OWID_WRL,-6000,13278309
World,OWID_WRL,-5000,19155698
World,OWID_WRL,-4000,28859174
World,OWID_WRL,-3000,44577880
World,OWID_WRL,-2000,72685064
World,OWID_WRL,-1000,110530464
World,OWID_WRL,0,232268832
World,OWID_WRL,100,237052192
World,OWID_WRL,200,240762160
World,OWID_WRL,300,227702848
World,OWID_WRL,400,241697008
World,OWID_WRL,500,253395808
World,OWID_WRL,600,271638944
World,OWID_WRL,700,278346080
World,OWID_WRL,800,285870176
World,OWID_WRL,900,311142688
World,OWID_WRL,1000,323462624
World,OWID_WRL,1500,503051104
World,OWID_WRL,1600,516147616
World,OWID_WRL,1700,595456896
World,OWID_WRL,1800,954892352
World,OWID_WRL,1820,1065623616
World,OWID_WRL,1830,1148205440
World,OWID_WRL,1840,1209754496
World,OWID_WRL,1850,1287033856
World,OWID_WRL,1950,2493092801
World,OWID_WRL,1951,2536926981
World,OWID_WRL,1952,2584086282
World,OWID_WRL,1953,2634106196
World,OWID_WRL,1954,2685894824
World,OWID_WRL,1955,2740213742
World,OWID_WRL,1960,3015470858
World,OWID_WRL,1965,3334533671
World,OWID_WRL,1970,3694683753
World,OWID_WRL,1975,4070735208
World,OWID_WRL,1980,4447606162
World,OWID_WRL,1985,4868943409
World,OWID_WRL,1990,5327803039
World,OWID_WRL,1995,5758878939
World,OWID_WRL,2000,6171702952
World,OWID_WRL,2005,6586970109
World,OWID_WRL,2010,7021732097
World,OWID_WRL,2015,7470491849
World,OWID_WRL,2020,7887001253
World,OWID_WRL,2021,7954448327
World,OWID_WRL,2022,8021407128
World,OWID_WRL,2023,8091734853
World,OWID_WRL,2024,8161972496
World,OWID_WRL,2025,8231613055
World,OWID_WRL,2030,8569124874
World,OWID_WRL,2040,9177190161
World,OWID_WRL,2050,9664378554
World,OWID_WRL,2060,9989232258
World,OWID_WRL,2070,10189241908
World,OWID_WRL,2080,10283077976
World,OWID_WRL,2090,10271565034
World,OWID_WRL,2100,10180160680`;

    // --- STATE MACHINE ---
    const storyMachine = createMachine({
      id: 'story',
      initial: 'loading',
      states: {
        loading: { on: { LOADED: 'sphere' } },
        sphere: { on: { EXPLODE: 'exploding' } },
        exploding: { after: { 8000: 'grid' } },
        grid: { on: { JOURNEY: 'journeying' } },
        journeying: { after: { 7000: 'earth' } },
        earth: { on: { CHART: 'chart' } },
        chart: { type: 'final' }
      }
    });

    // --- SHADERS (Original) ---
    const particleVertexShader = `
        attribute float size;
        attribute vec3 aTargetPos;
        attribute float aDelay;
        varying vec3 vColor;
        uniform vec3 uMouse;
        uniform float uInteractionRadius;
        uniform float uTransitionProgress;
        varying float vHighlight;
        void main() {
            vColor = color;
            float duration = 1.5; 
            float t = clamp((uTransitionProgress - aDelay) / duration, 0.0, 1.0);
            t = t * t * (3.0 - 2.0 * t); 
            vec3 currentPos = mix(position, aTargetPos, t);
            float dist = length(currentPos - uMouse);
            float falloff = 1.0;
            vHighlight = 1.0 - smoothstep(uInteractionRadius, uInteractionRadius + falloff, dist);
            vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
            gl_PointSize = min(size * (300.0 / -mvPosition.z), 6.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    `;

    const particleFragmentShader = `
        varying vec3 vColor;
        varying float vHighlight;
        void main() {
            if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
            vec3 highlightColor = vec3(1.0, 1.0, 1.0);
            vec3 finalColor = mix(vColor, highlightColor, vHighlight) * 1.5; 
            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

    const atmosphereVertexShader = `
        varying vec3 vNormal; 
        void main(){
            vNormal = normalize(normalMatrix * normal); 
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `;

    const atmosphereFragmentShader = `
        uniform vec3 glowColor; uniform float c; uniform float p; varying vec3 vNormal;
        void main(){
            float intensity = pow(c - dot(vNormal, vec3(0.0,0.0,1.0)), p); 
            gl_FragColor = vec4(glowColor * intensity, 1.0);
        }
    `;

    // --- GLOBAL STORE (For inter-component communication in simple React setups) ---
    // We use this to pass the target particle position from Particles -> Camera
    const globalStore = {
        targetPos: new THREE.Vector3()
    };

    // --- COMPONENT: EFFECTS (Bloom) ---
    function Effects() {
        const { gl, scene, camera, size } = useThree();
        const composer = useRef();

        useEffect(() => {
            composer.current = new EffectComposer(gl);
            const renderPass = new RenderPass(scene, camera);
            composer.current.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(size.width, size.height), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.0;
            bloomPass.radius = 0.5;
            composer.current.addPass(bloomPass);

            return () => composer.current.dispose();
        }, [gl, scene, camera, size]);

        useFrame(() => composer.current?.render(), 1);
        return null;
    }

    // --- COMPONENT: PARTICLES ---
    function Particles({ state }) {
        const count = 15000; // Original Count
        const mesh = useRef();
        const materialRef = useRef();
        const { mouse, camera } = useThree();
        
        const data = useMemo(() => {
            const positions = new Float32Array(count * 3);
            const targetPositions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const delays = new Float32Array(count);
            
            const sphereRadius = 0.2;
            const gridDimensions = 160;
            const color = new THREE.Color();
            const targetIdx = Math.floor(Math.random() * count);
            
            for (let i = 0; i < count; i++) {
                // Sphere Position
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                positions[i*3] = sphereRadius * Math.cos(theta) * Math.sin(phi);
                positions[i*3+1] = sphereRadius * Math.sin(theta) * Math.sin(phi);
                positions[i*3+2] = sphereRadius * Math.cos(phi);

                // Color (Rainbow HSL)
                color.setHSL(i / count, 0.5, 0.7);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;

                sizes[i] = Math.random() * 0.2 + 0.01;

                // Grid Position
                const gx = (Math.random() - 0.5) * gridDimensions;
                const gy = (Math.random() - 0.5) * gridDimensions;
                const gz = (Math.random() - 0.5) * gridDimensions;
                targetPositions[i*3] = gx;
                targetPositions[i*3+1] = gy;
                targetPositions[i*3+2] = gz;
                
                delays[i] = Math.random() * 1.5;

                if (i === targetIdx) {
                    globalStore.targetPos.set(gx, gy, gz);
                    sizes[i] = 0; // Hide target
                }
            }
            return { positions, targetPositions, colors, sizes, delays };
        }, []);

        // Animation
        useEffect(() => {
            if (state.matches('exploding')) {
                const mat = materialRef.current;
                gsap.to(mat.uniforms.uInteractionRadius, { value: 6.0, duration: 8, ease: "power3.inOut" });
                gsap.to(mat.uniforms.uTransitionProgress, { value: 3.5, duration: 10.0, ease: "power2.inOut" });
            }
        }, [state.value]);

        useFrame(() => {
            if (materialRef.current) {
                // Raycast for Mouse Interaction
                const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vec.unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                materialRef.current.uniforms.uMouse.value.copy(pos);
            }
        });

        return (
            <points ref={mesh}>
                <bufferGeometry>
                    <bufferAttribute attach="attributes-position" count={count} array={data.positions} itemSize={3} />
                    <bufferAttribute attach="attributes-aTargetPos" count={count} array={data.targetPositions} itemSize={3} />
                    <bufferAttribute attach="attributes-color" count={count} array={data.colors} itemSize={3} />
                    <bufferAttribute attach="attributes-size" count={count} array={data.sizes} itemSize={1} />
                    <bufferAttribute attach="attributes-aDelay" count={count} array={data.delays} itemSize={1} />
                </bufferGeometry>
                <shaderMaterial
                    ref={materialRef}
                    vertexShader={particleVertexShader}
                    fragmentShader={particleFragmentShader}
                    uniforms={{
                        uMouse: { value: new THREE.Vector3(-100, -100, 0) },
                        uInteractionRadius: { value: 1.5 },
                        uTransitionProgress: { value: 0.0 }
                    }}
                    vertexColors={true} transparent={true} depthWrite={false} blending={THREE.AdditiveBlending}
                />
            </points>
        );
    }

    // --- COMPONENT: EARTH ---
    function Earth({ visible }) {
        const group = useRef();
        const earthRef = useRef();
        const cloudsRef = useRef();

        const [map, normal, specular, clouds] = useMemo(() => {
             const tl = new THREE.TextureLoader();
             tl.setCrossOrigin('anonymous');
             return [
                 tl.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_atmos_2048.jpg'),
                 tl.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_normal_2048.jpg'),
                 tl.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_specular_2048.jpg'),
                 tl.load('https://cs.wellesley.edu/~cs307/threejs/r124/three.js-master/examples/textures/planets/earth_clouds_1024.png')
             ];
        }, []);

        useLayoutEffect(() => {
            if (group.current) group.current.position.copy(globalStore.targetPos);
        });

        useFrame(() => {
            if (earthRef.current) earthRef.current.rotation.y += 0.0005;
            if (cloudsRef.current) cloudsRef.current.rotation.y += 0.0006;
        });

        return (
            <group ref={group} visible={visible}>
                <mesh ref={earthRef}>
                    <sphereGeometry args={[0.5, 64, 64]} />
                    <meshPhongMaterial map={map} bumpMap={normal} bumpScale={0.005} specularMap={specular} shininess={5} />
                </mesh>
                <mesh ref={cloudsRef}>
                    <sphereGeometry args={[0.503, 64, 64]} />
                    <meshPhongMaterial map={clouds} transparent={true} depthWrite={false} side={THREE.FrontSide} />
                </mesh>
                <mesh>
                    <sphereGeometry args={[0.53, 64, 64]} />
                    <shaderMaterial vertexShader={atmosphereVertexShader} fragmentShader={atmosphereFragmentShader}
                        uniforms={{ c: { value: 1.0 }, p: { value: 2.0 }, glowColor: { value: new THREE.Color(0x3b8ff) } }}
                        side={THREE.BackSide} blending={THREE.AdditiveBlending} transparent={true}
                    />
                </mesh>
            </group>
        );
    }

    // --- COMPONENT: CAMERA RIG ---
    function CameraRig({ state }) {
        const { camera } = useThree();
        const scroll = useScroll();

        useEffect(() => {
            if (state.matches('journeying')) {
                const startPos = camera.position.clone();
                const endPos = globalStore.targetPos.clone().add(new THREE.Vector3(0, 0.25, 2.0)); // Earth offset
                
                const controlPoint = new THREE.Vector3()
                    .lerpVectors(startPos, endPos, 0.5)
                    .add(new THREE.Vector3(0, startPos.distanceTo(endPos) * 0.2, 0));

                const curve = new THREE.QuadraticBezierCurve3(startPos, controlPoint, endPos);
                const lookAtProxy = { x: 0, y: 0, z: 0 }; 
                const journeyProxy = { t: 0 };

                gsap.to(lookAtProxy, {
                    x: globalStore.targetPos.x, y: globalStore.targetPos.y, z: globalStore.targetPos.z,
                    duration: 5, ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(lookAtProxy.x, lookAtProxy.y, lookAtProxy.z)
                });

                gsap.to(journeyProxy, {
                    t: 1, duration: 7, ease: "power3.inOut",
                    onUpdate: () => {
                        camera.position.copy(curve.getPoint(journeyProxy.t));
                        camera.lookAt(globalStore.targetPos);
                    }
                });
            }
        }, [state.value]);

        useFrame(() => {
            if (state.matches('sphere') || state.matches('exploding') || state.matches('grid')) {
                // Zoom Logic: Map scroll 0..1 to Zoom 35..3
                // Note: We multiply offset to mimic the long scroll distance feeling
                // In original: zoom = 35 - (scrollY / 60). 
                // Here we just linear interpolate based on progress.
                const zoom = 35 - (scroll.offset * 30); 
                camera.position.z = Math.max(zoom, 3);
            }
        });
        return null;
    }

    // --- COMPONENT: CHART ---
    function PopulationChart({ visible }) {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);
        const [stat, setStat] = useState({ year: 0, pop: 0 });

        useEffect(() => {
            if (!visible || !canvasRef.current) return;
            if (chartRef.current) return;

            const rawData = CSV_DATA.trim().split('\n').slice(1).map(line => {
                const p = line.split(','); return { x: parseInt(p[2]), y: parseInt(p[3]) };
            }).filter(d => d.x <= 2025).sort((a, b) => a.x - b.x);

            const ctx = canvasRef.current.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 600);
            gradient.addColorStop(0, 'rgba(147, 51, 234, 0.6)');
            gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');

            chartRef.current = new Chart(ctx, {
                type: 'line',
                data: { datasets: [{ label: 'Population', data: [rawData[0]], borderColor: '#c084fc', backgroundColor: gradient, borderWidth: 2, pointRadius: 0, fill: true, tension: 0.4 }] },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    interaction: { mode: 'nearest', axis: 'x', intersect: false },
                    scales: {
                        x: { type: 'linear', min: -10000, max: 2025, grid: { display: false }, ticks: { color: '#94a3b8', callback: v => Math.abs(v) + (v<0?' BC':'') } },
                        y: { type: 'linear', min: 0, max: 2000000000, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#94a3b8', callback: v => (v/1e9).toFixed(0)+'B' } }
                    },
                    plugins: { legend: {display: false} }
                }
            });

            let currentYear = -10000, currentMaxY = 2000000000, animId;
            function loop() {
                let step = (currentYear < 1800) ? 30 : 1;
                currentYear += step;
                if (currentYear > 2025) currentYear = 2025;

                const nextIndex = rawData.findIndex(d => d.x > currentYear);
                let val = (nextIndex !== -1 && nextIndex !== 0) ? 
                    rawData[nextIndex-1].y + (rawData[nextIndex].y - rawData[nextIndex-1].y) * ((currentYear - rawData[nextIndex-1].x) / (rawData[nextIndex].x - rawData[nextIndex-1].x)) 
                    : rawData[rawData.length-1].y;

                setStat({ year: currentYear, pop: val });

                const filtered = rawData.filter(d => d.x <= currentYear);
                filtered.push({ x: currentYear, y: val });
                chartRef.current.data.datasets[0].data = filtered;
                
                if (val > currentMaxY * 0.8) { currentMaxY += 50000000; chartRef.current.options.scales.y.max = currentMaxY; }
                chartRef.current.update('none');

                if (currentYear < 2025) animId = requestAnimationFrame(loop);
            }
            loop();
            return () => cancelAnimationFrame(animId);
        }, [visible]);

        if (!visible) return null;
        return (
            <div className="fixed inset-0 z-50 flex flex-col pointer-events-auto animate-fade-in opacity-100 transition-opacity duration-500">
                <div className="absolute top-4 left-0 w-full text-center z-10 pointer-events-none">
                    <h1 className="text-3xl sm:text-5xl font-thin text-white tracking-wider" style={{fontFamily: 'EB Garamond'}}>Humanity</h1>
                    <p className="text-sky-300/70 text-sm sm:text-base mt-1 font-light">The Rise of Population</p>
                </div>
                <div className="relative w-full h-full max-w-6xl mx-auto flex flex-col justify-center p-4 sm:p-8">
                    <div className="absolute inset-4 sm:inset-8 bg-slate-900/30 backdrop-blur-sm rounded-xl border border-white/10 shadow-2xl -z-10"></div>
                    <div className="relative w-full h-[70vh] sm:h-[80vh]">
                        <canvas ref={canvasRef} id="popChart"></canvas>
                        <div className="absolute top-4 left-4 sm:left-8 pointer-events-none">
                            <div className="text-gray-400 text-xs sm:text-sm uppercase tracking-widest">Year {Math.abs(stat.year)}{stat.year < 0 ? ' BC' : ''}</div>
                            <div className="text-3xl sm:text-5xl text-white font-medium tabular-nums" style={{fontFamily: 'EB Garamond', textShadow: '0 0 20px rgba(56, 189, 248, 0.5)'}}>
                                {stat.pop > 1e9 ? (stat.pop/1e9).toFixed(2) + 'B' : (stat.pop/1e6).toFixed(1) + 'M'}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    // --- MAIN APP ---
    function Experience() {
        const [state, send] = useMachine(storyMachine);
        const scroll = useScroll();

        // Remove Loader when ready
        useEffect(() => {
            send({ type: 'LOADED' });
            const loader = document.getElementById('loader');
            if(loader) {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }
        }, []);

        useFrame(() => {
            // Trigger calibration roughly matching original pixel depths relative to a 4-page scroll
            if (state.matches('sphere') && scroll.offset > 0.1) send({ type: 'EXPLODE' });
            if (state.matches('grid') && scroll.offset > 0.5) send({ type: 'JOURNEY' });
            if (state.matches('earth') && scroll.offset > 0.9) send({ type: 'CHART' });
        });

        return (
            <>
                <Effects />
                <directionalLight position={[5, 3, 5]} intensity={2} />
                <ambientLight intensity={0.6} />
                <fog attach="fog" args={['#111', 10, 20]} />

                <Particles state={state} />
                <Earth visible={state.matches('journeying') || state.matches('earth') || state.matches('chart')} />
                <CameraRig state={state} />

                <Scroll html style={{ width: '100%' }}>
                    {/* INTRO SECTION */}
                    <div className="h-screen flex flex-col items-center justify-center">
                        <div className={`caption-card transition-opacity duration-700 ${state.matches('sphere') ? 'opacity-100' : 'opacity-0'}`}>
                            Au début, l’univers tout entier tenait ici.
                        </div>
                        <div className={`absolute bottom-[8%] scroll-arrow ${state.matches('sphere') ? 'opacity-100' : 'opacity-0'}`}>&#x25BD;</div>
                    </div>
                    
                    <div className="h-[100vh]"></div>

                    {/* EARTH CAPTION */}
                    <div className="h-screen flex flex-col items-center justify-center pointer-events-none">
                        <div className={`caption-card transition-opacity duration-1000 ${state.matches('earth') ? 'opacity-100' : 'opacity-0'}`}>
                            Maintenant, toute l’humanité se tient là.
                        </div>
                    </div>

                    <div className="h-[150vh]"></div>
                </Scroll>

                <Html fullscreen style={{pointerEvents: state.matches('chart') ? 'auto' : 'none'}}>
                    <PopulationChart visible={state.matches('chart')} />
                </Html>
            </>
        );
    }

    function App() {
        // Match Original Camera: FOV 110, Z 40
        return (
            <Canvas dpr={[1, 2]} gl={{ toneMapping: THREE.ReinhardToneMapping }} camera={{ fov: 110, position: [0, 0, 40] }}>
                <ScrollControls pages={4} damping={0.2}>
                   <Experience />
                </ScrollControls>
            </Canvas>
        );
    }

    createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
